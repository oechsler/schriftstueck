\section{Domain Driven Design}
\label{sec:domain_driven_design}

\subsection{Ubiquitous Language}
\label{subsec:ubiquitous_language}

\begin{table}[H]
    \centering
    
    \settowidth\tymin{\texttt{LoadBalancedDeployment}}
    \begin{tabulary}{\textwidth}{|L|L|} 
        \hline
        \textbf{Keyword} & \textbf{Erklärung} \\
        \hline
        \texttt{Config}  & Abbildung der Konfigurationsdatei mit allen Sektionen \\
        \hline
        \texttt{AuthConfig} & Abschnitt in der \texttt{Config} spezifisch für Authentifizierung \\
        \hline
        \texttt{AuthToken} & Token mit dem sich ein Nutzer an der API authentifiziert \\
        \hline
        \texttt{Script} & Ein generisches, ausführbares Skript der DSL \\
        \hline
        \texttt{Resources} & Aggregat mehrerer Scripts zur sequenziellen Abarbeitung \\
        \hline
        \texttt{Deployment} & Abbildung eines \texttt{Deployments} auf der Plattform \\
        \hline
        \texttt{Container} & Repräsentation eines Docker Containers der in einem \texttt{Deployment} liegt \\
        \hline
        \texttt{Image} & Ein Docker Image, welches vom Container genutzt wird \\
        \hline
        \texttt{Port} & Abbildung eines Socket Ports \\
        \hline
        \texttt{Path} & Ein bestimmter, absoluter Pfad auf dem Unix Dateisystem \\
        \hline
        \texttt{Permission} & Abbildung einer Unix Dateisystem Berechtigung \\
        \hline
        \texttt{Mount} & Zuweisung von \texttt{Storage} auf bestimmten Einhängepunkt eines \texttt{Deployments} \\
        \hline
        \texttt{MountType} & Die spezifische Art eines Einhängepunktes \\
        \hline
        \texttt{Domain} & Stellt eine FQDN dar, die in einer Liste von \texttt{PublishedDomains} auftaucht \\
        \hline
        \texttt{Publish} & Aggregat von \texttt{PublishedPorts} und \texttt{PublishedDomains} für ein \texttt{Deployment} \\
        \hline
        \texttt{PublishedPort} & Zuweisung eines Container Ports auf einen zufälligen öffentlichen Port \\
        \hline
        \texttt{PublishedDomains} & Zuweisung eines Container Ports auf eine bestimmte Domain \\
        \hline
        \texttt{LoadBalancer} & Lastverteiler auf der Plattform \\
        \hline
        \texttt{LoadBalancedDeployment} & Ein \texttt{Deployment}, das an einen \texttt{LoadBalancer} gekoppelt ist \\
        \hline
        \texttt{Storage} & Abbildung eines Speichermediums mit \texttt{StorageClass} und Size auf der Plattform \\
        \hline
        \texttt{StorageClass} & Die spezifische Art eines Speichermediums \\
        \hline
        \texttt{Size} & Abbildung einer beliebigen Speichergröße normiert auf Gigabyte \\
        \hline
    \end{tabulary}

    \caption{Die \emph{Ubiquitous Language} der Anwendung}
    \label{tab:vergleich_tooling_support}
\end{table}

\subsection{Entwurfsmuster}
\label{subsec:entwurfsmuster}

Das \emph{Domain Driven Design} benötigt zur korrekten Umsetzung einige spezifische Entwurfsmuster.
Dieser Abschnitt soll das Projekt in jener Hinsicht analysieren und die Verwendung der Muster an konkreten Beispielen begründen.

Die zu verwendenden Muster sind nachfolgend kurz aufgelistet:

\begin{itemize}
    \item \emph{Aggregates} -- Ein Verbund von Domänen-Objekten zu einer Einheit
    \item \emph{Entities} -- Objekte mit veränderlicher Eigenschaft; einzigartige Identität 
    \item \emph{Value Objects} -- Durch ihre Eigenschaft unveränderliche, eindeutige Objekte 
    \item \emph{Domain Services} -- Abbildung relevanter Funktionalität für mehrere Objekte
    \item \emph{Repositories} -- Abstraktion der Daten- und Persistierungsschicht
\end{itemize}

\paragraph{Aggregates} 

Wie bereits aus der in \Cref{tab:vergleich_tooling_support} hervorgeht, verwendet die Anwendung \emph{Aggregates}.
Ein konkretes Beispiel hierfür ist die Klasse \texttt{LoadBalancer}.
Sie Bündelt mehrere \emph{Script} Entitäten zu einem Verbundobjekt, mit dem es möglich wird die Skripte sequenziell auszuführen.
Die Bündelung erfolgt in einer Liste von \texttt{Script} Interfaces.
Ein \texttt{Skript} ist im Rahmen der Domäne eine generische Abbildung einer ausführbaren Programmcode-Datei.
Das \texttt{Resources} \emph{Aggregate} selbst is ebenfalls ein \texttt{Script}.

Aufgrund der spezifischen Umsetzung in der DSL ist das als \emph{Aggregate} bezeichnete \texttt{Resources} Objekt nicht im Code enthalten und nur fiktiv existent. 
Wäre die Umsetzung als echtes \emph{Aggregate} erfolg, so könnte die generalisierung auf einen Verbund von \texttt{Script} Objekten, das selbst ein \texttt{Script} ist nicht stattfinden.
Hierzu ist es jedoch wichtig zu verstehen wie ein \texttt{Script} genutzt wird.
Das Interface bietet zwei Methoden an, die spezifisch für das Auführen und das Zurückrollen der Änderungen implementiert sind.
Diese Methoden haben einen \texttt{void} Rückgabetyp.
Da jedes \texttt{Script} in sich selbst vollständig Arbeitet müssen die Skripte auch nicht voneinander in Kenntnis gesetzt werden.
Eine \enquote{Ansammlung} der Skripte muss also nicht stattfinden. 
Zukünftig wäre allerdings die Sammlung an Ausgaben, die vom Evaluieren des Skriptes zurückkommen und weiterverwendet werden als solches \emph{Aggregate} zu definieren.
Daher hier das Beispiel.
Im \Cref{lst:ressources_builder} ist der genaue Aufbau der benannten Thematik visualisiert.

\bgroup
    \kotlinfile{assets/ResourcesBuilder.kt}

    \captionof{listing}{Der Builder für das \emph{virtuelle} \emph{Aggregate} \texttt{Resources}}
    \label{lst:ressources_builder}
\egroup

\paragraph{Entities} 

Als Solche lässt sich in der Anwendung bisher nur die Konfiguration im Objekt \texttt{Config} (siehe \Cref{lst:config}) klassifizieren, jedoch auch nur entfernt.
Das liegt daran, dass sich die Konfiguration aufgrund der Natur eines \emph{Commandline Tools} über den Lebenszyklus maximal einmal verändert.
Anschließend muss vom Benutzer ein neuer Durchlauf der Anwendung angefordert werden mit anderen Bedingungen.
Lässt man das jedoch außer Acht, so erfüllt das \texttt{Config} die zuvor deklarierten Anforderungen.

\bgroup
    \kotlinfile{assets/Config.kt}

    \captionof{listing}{Codebeispiel der \emph{Entität} \texttt{Config}}
    \label{lst:config}
\egroup

\paragraph{Value Objects} 

Gemessen an der Definition sind alle für die interne DSL verwendete Datenobjekte \emph{Value Objects} (siehe Paket \texttt{it.oechsler.snug.script.data}).
Daher folgt an dieser Stelle kein explizites Beispiel.
Sie jeweils unveränderlich und spiegeln die Identität aus den Eigenschaften ihrer selbst wider.
Zu diesem Schluss führt darüberhinaus, wenn man sich die Funktion der Datenobjekte klar macht.
Sie bilden das Ergebnis der Transformationen aus dem Programmcode der DSL in die Zielsprache (in diesem Fall JSON).
Mann kann sie im engeren Sinne mit den Lexemen einer Sprache vergleichen.

\paragraph{Domain Services}

In der Anwendung gibt es mehrere Bereiche in denen spezifische Funktionalitäten (\emph{Use Cases}) gebündelt werden müssen.
Hierfür kommen dann \emph{Services} zum Einsatz.
Ein spezigisches Beispiel für solch eine Bündelung von Funktionalität ist der \texttt{ScriptService}.
Er kapselt den \emph{Use Case} des überführens von Programmcode in Kotlin spezifische Objekte. Das nachfolgende \Cref{lst:script_service} zeigt die Implementierung der gekapselten Funktionalität im \emph{Service}.

\bgroup
    \kotlinfile{assets/ScriptServiceImpl.kt}

    \captionof{listing}{Codebeispiel der Implementierung des \emph{Service} \texttt{ScriptService}}
    \label{lst:script_service}
\egroup

\paragraph{Repositories}

Dieses Entwurfsmuster wurde auch innerhalb der Anwendung umgesetzt.
Erneut findet es sich zur verwaltung der Konfiguration und damit im Zuge der \emph{Entity} \texttt{Config} als \texttt{ConfigRepository}.
Es dient konkret zum abstrahieren der, hier in Form einer Datei vorhandenen, Persistierungsschicht.
Das Beispiel in \Cref*{lst:config_repository} zeigt dessen Implementierung.

\bgroup
    \kotlinfile{assets/ConfigRepositoryImpl.kt}

    \captionof{listing}{Codebeispiel der Implementierung des \emph{Repository} \texttt{ConfigRepository}}
    \label{lst:config_repository}
\egroup